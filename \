import type {
  BaseEntity,
  AnalyzedEntity,
  AssociatedEntity,
  FinalEntity
} from "../entity";


import * as et from "../entity"
import * as as from "../association";
import * as ss from "../series"
import { isArticle, isCourse, isSeries } from "../entity/filters";

export type OutputTable =
  | BaseTable
  | AnalyzedTable
  | AnalyzedTable
  | FinalTable;

export type BaseTable = BaseEntity[];
export type AnalyzedTable = AnalyzedEntity[];
export type AssociatedTable = AssociatedEntity[];
export type FinalTable = FinalEntity[];


export async function analyze(table: BaseTable) {
  console.log(`ANALYZING ${table.length} ENTITIES`)
  const promises = table.map(entity => et.analyze(entity))
  return await Promise.all(promises);
}

export function initCollections(table: AnalyzedTable) {
  const series = table.reduce((acc, entity) => {
    const { series } = entity.meta;
    if (!series) { return acc };
    const existing = series && acc.get(series);
    return existing ? acc.set(series, [...existing, entity]) : acc.set(series, [entity]);
  }, new Map<string, AnalyzedTable>)
  const seriesEntities = Array.from(series).map(([series, v]) => {
    const author = v[0]?.meta.author!
    const titles = v.map(({ meta }) => meta.title);
    return ss.init({ series, author, titles })
  })
  // const allTags = table.flatMap(({ analysis }) => analysis.tags);
  // const tagEntities = [...new Set([...allTags])].map(tag => t.init({ tag }));
  return [...seriesEntities]
}

export function associate(table: AnalyzedTable) {
  console.log(`ASSOCIATING ${table.length} ENTITIES`)
  return table.map((entity) => {
    return et.associate(table, entity)
  })
}

export async function augment(table: AssociatedTable) {
  console.log(`AUGMENTING ${table.length} ENTITIES`)
  const promises = table.map(entity => et.augment(entity))
  return await Promise.all(promises);
}

export async function write(basePath: string, table: FinalTable) {
  for (const entity of table) {
    et.write(basePath, entity);
  }
}

export function findCourseForArticle(table: AnalyzedTable, title: string) {
  return table
    .filter(isCourse)
    .find(other => other.meta.habitat === title ||
      other.meta.title === title)
}

export function findArticleforCourse(table: AnalyzedTable, habitat: string) {
  return table
    .filter(isArticle)
    .find(other => other.meta.title === habitat)
}

export function findArticlesForAuthor(table: AnalyzedTable, author: string) {
  return table
    .filter(isArticle)
    .filter(other => other.meta.author === author)
}

export function findCoursesForAuthor(table: AnalyzedTable, author: string) {
  return table
    .filter(isCourse)
    .filter(other => other.meta.author === author)
}

export function findSeriesForAuthor(table: AnalyzedTable, author: string) {
  console.log(table.filter(isSeries))
  return table
    .filter(isSeries)
    .filter(other => other.meta.author === author)
}


export function findSeriesForArticle(table: AnalyzedTable, series: string) {
  return table
    .filter(isArticle)
    .filter(other => other.meta.series === series)
}
